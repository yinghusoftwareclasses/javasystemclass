Java工程师体系课第六周作业

题目 01：
一条	SQL 语句在 MySQL 中是如何执行的？
第一步： 链接数据库服务器，从客户端发出的指令到达数据库。客户端首先要通过用户和密码验证。
第二步：服务器首先查缓存，看看最近是否有过同样的查询指令。如果有，直接返回缓存的结果。实践中缓存效率很低，所以MySql8.0之后没有缓存这个功能了。
第三步： 分析语句。这一步和一般的编程语言编译过程类似。先是变成token,然后是建立语法分析树，检查是否有语法错误，然后会做预处理，进一步检查错误，比如检查操作的表是否存在等。
第四步：优化执行策略。主要是优化磁盘操作，也会优化cpu时间。优化磁盘操作时通过relational algebra找到等价的操作，然后通过计算各种操作所需的磁盘操作数进行优化。
第五步： 执行语句。其中要检查用户权限，并通过存储引擎接口访问存储引擎。Mysql支持多种存储引擎，缺省值是innodb.
题目 02
请解释一下你理解的事务是什么？
要点：
1.	事务四大特性 ACID
A:  atomicity. 所有同一个事务的语句效果上就像是一个不可分割的语句。 
C: consistency. 数据是一致的。比如在同一个银行从一个账户转钱到另一个账户，银行的总钱数不变。这条主要是指在操作过程中有些不变量是要保持不变的。具体哪些是不变量要看业务。
I: Isolation. 在一个事务的操作过程中，它的中间态别的事务是看不见的。对其它事务来说，要么看到之前的，要么看到之后的。这样有助于保持一致性。
D: Durability. 事务结束后数据不会丢失。主要是通过把数据和log写入磁盘实现。不同的写入时间会保证不同的durability可靠性。
2.	事务隔离级别
读未提交：事务A可读事务B 未提交的修改。
读已提交： 事务A只能读B已提交的修改。
可重复读：同一个事务中的读操作读出的数据是一样的。事务A只能读B已提交的修改， 同时也只能读到事务A自己已提交的修改。这是innodb的缺省选项。
可窜行化：两个事务同时执行的效果和一先一后执行的效果一样。这是最高级别的隔离。

3.	事务会产生的并发问题
脏读：A读到了B 未提交的修改的数据。
不可重复读：如果B有多次提交，A可以读到多次提交的值。读未提交和读已提交都可能导致这个问题。
幻读：A先读了一些结果。B提交了一些新增结果符合A的查询条件，A再读时发现出了新的数据。读未提交，读已提交和可重复读都可能导致这个问题。

4.	事务的安全性、性能与隔离级别的关系
	脏读	不可重复读	幻读
读未提交	可能	可能	可能
读已提交	不会	可能	可能
可重复读	不会	不会	可能
窜行化	不会	不会	不会


