Java工程师体系课第二周作业

题目 01- 请你用自己的语言向我介绍 Java 运行时数据区（内存区域）
•	堆、虚拟机栈、本地方法栈、方法区（永久代、元空间）、运行时常量池（字符串常量池）、直接内存
•	为什么堆内存要分年轻代和老年代？

堆： 用来存放运行时分配的对象，这些对象是全局可见，任何线程都可以使用，主要分为新区，老区和永久区。如果堆满了，再分配内存就会产生OOM错误。堆中的对象要经过垃圾回收才会释放。存取速度比栈要慢一点。线程不安全。
虚拟机栈：每个线程有自己的。主要是存放线程的函数栈用到的原始数据，本地变量，还有函数产生的对象的引用。函数栈退出后内存自动释放。线程安全。存取速度比栈快。使用先进后出的方式。最大的缺点是大小非常有限。
本地方法栈：本地方法栈是用来调用本地方法时用的栈。栈的原理和虚拟机栈类似。本地方法是指Java之外的方法，通常是用来和操作系统底层及硬件打交道时用的，通常用C/C++实现。
方法区（永久代、元空间）：方法去是独立于堆的一块内存，主要用于存放Java 字节码，类定义，和即使编译的字节码。Java8以前叫永久代，之后叫元空间。
 运行时常量池（字符串常量池）：用来存放字符串常量。一般需要编译时就知道的常量，但也可以通过Intern()方法在运行时加入。主要优点是同一个字符只需要一份。避免分配内存及回收的开销。常量池也放一些小的原始数据的等同类对象。常量池还可以放class常量。常量池是通过哈希表来存取。
直接内存： 是独立于堆的一块内存。由操作系统直接负责，主要用来提高I/O速度。不垃圾回收。
为什么堆内存要分年轻代和老年代： 主要是因为实践中，刚分配的对象常常很快被回收，越老的对象越不会被回收，并且决定多数对象寿命都很短。把堆分成年轻代和老年代可以优化垃圾回收，回收时花更多时间在年轻代，因为它们更大可能被回收。

题目 02- 描述一个 Java 对象的生命周期
•	解释一个对象的创建过程
•	解释一个对象的内存分配
•	解释一个对象的销毁过程
•	对象的 2 种访问方式是什么？
•	为什么需要内存担保？

一个对象的生命周期主要包括创建（new）,初始化（构造函数），使用，和销毁。
解释一个对象的创建过程： 一个对象是通过new()来创建。new() 返回的是个引用。程序可以通过这个引用来使用这个对象。在创建对象时如果这个类还没被加载，就会首先通过双亲委派及其它一些方式来加载这个类。对于某些常量，也不一定分配内存，而是首先查常量池。

解释一个对象的内存分配: JVM 会在堆上分配一块内存。这块内存能放下对象头，对象的数据，及结尾的padding,每次的内存大小都是8的倍数。

解释一个对象的销毁过程: 对象是通过垃圾回收的销毁的。垃圾回收是JVM的背景操作。当一个对象不在被引用是就又可能被回收。用户一般没有办法控制什么时候会被回收。引用有几种。最常见的是强引用，还有软引用，弱引用和幻引用。每种引用的收回时间不一样。在被垃圾回收之前finalize()会被调用一次。

对象的 2 种访问方式是什么： 通过句柄访问对象和通过直接指针访问对象（速度更快）。

为什么需要内存担保：当新生代无法分配内存时，会把新生代的老对象放到老年代。这样新生代就有空间分配内存。


题目 03- 垃圾收集算法有哪些？垃圾收集器有哪些？他们的特点是什么？
•	ParNew 收集器
•	ParallelScavenge 收集器
•	ParallelOld 收集器
•	CMS 收集器
•	G1 收集器

垃圾回收算法：
找垃圾： 引用计数法，无法处理循环引用。 跟可达法：从根节点（一般在栈上或全局变量）开始，顺着引用往下找，所有不能到达的都可以被回收。
回收算法：
标记清除算法。第一次标记所有可回收的，然后查哪些要掉finalize(), 然后第二次标记。回收所有标记的对象。优点是简单，缺点是效率不高，容易产生碎片。
拷贝算法。把不要回收的拷贝到另外一个区，这样刚处理完的区就可全部回收。优点是没有碎片，缺点是内存浪费，因为要准备一个区。
标记真理算法。 不拷贝到一个新区，而是所有对象往前挪。优点是无碎片，无内存浪费，缺点是效率不高。

垃圾收集器有8种。Serial （新生代窜行）、ParNew（新生代并行）、Parallel Scavenge（新生代并行复制）是新生代。Serial Old（老生代窜行）、Parallel Old（老生代并行和标记整理）、CMS（并行回收，并尽量避免STW）是老生代。新生代和老生代可以混合使用。G1(Gargabe first)、ZGC是整体。

ParNew 收集器： 新生代并行，老生代窜行。
ParallelScavenge 收集器: 新生代并行复制
ParallelOld 收集器: 老生代并行和标记整理
CMS: 并行回收，并尽量避免STW
G1: 并行与并发, 多代收集,可预测时间。





